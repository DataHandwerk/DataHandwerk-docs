= [repo].[ftv_GeneratorUspStep_tree]

== existing_properties

// tag::existing_properties[]
:ExistsProperty--AntoraReferencedList:
:ExistsProperty--AntoraReferencingList:
:ExistsProperty--ReferencedObjectList:
:ExistsProperty--sql_modules_definition:
:ExistsProperty--AntoraParameterList:
:ExistsProperty--Columns:
// end::existing_properties[]

== RepoObject_guid

// tag::RepoObject_guid[]
3390291C-9D61-EB11-84DC-A81E8446D5B0
// end::RepoObject_guid[]

== SysObject_type

// tag::SysObject_type[]
IF
// end::SysObject_type[]

== SysObject_type_name

// tag::SysObject_type_name[]
inline function
// end::SysObject_type_name[]

== SysObject_id

// tag::SysObject_id[]
866102126
// end::SysObject_id[]

== SysObject_modify_date

// tag::SysObject_modify_date[]
2021-01-29 11:18:36
// end::SysObject_modify_date[]

== AntoraColumnDetails

// tag::AntoraColumnDetails[]
[[column-Asc_PerParentChild]]
=== Asc_PerParentChild

[cols="d,m,m,m,m,d"]
|===
|
|Asc_PerParentChild
|bigint
|NULL
|
|
|===


[[column-child_PerParent]]
=== child_PerParent

[cols="d,m,m,m,m,d"]
|===
|
|child_PerParent
|bigint
|NULL
|
|
|===


[[column-Depth]]
=== Depth

[cols="d,m,m,m,m,d"]
|===
|
|Depth
|int
|NULL
|
|
|===


[[column-Desc_PerParentChild]]
=== Desc_PerParentChild

[cols="d,m,m,m,m,d"]
|===
|
|Desc_PerParentChild
|bigint
|NULL
|
|
|===


[[column-is_condition]]
=== is_condition

[cols="d,m,m,m,m,d"]
|===
|
|is_condition
|tinyint
|NULL
|
|
|===


[[column-is_required_ELSE]]
=== is_required_ELSE

[cols="d,m,m,m,m,d"]
|===
|
|is_required_ELSE
|int
|NOT NULL
|
|
|===


[[column-Number]]
=== Number

[cols="d,m,m,m,m,d"]
|===
|
|Number
|int
|NULL
|
|
|===


[[column-Parent_Number]]
=== Parent_Number

[cols="d,m,m,m,m,d"]
|===
|
|Parent_Number
|int
|NULL
|
|
|===


[[column-Parent_Sort]]
=== Parent_Sort

[cols="d,m,m,m,m,d"]
|===
|
|Parent_Sort
|int
|NULL
|
|
|===


[[column-Root_Sort]]
=== Root_Sort

[cols="d,m,m,m,m,d"]
|===
|
|Root_Sort
|int
|NULL
|
|
|===


[[column-RowNumber_PerUsp]]
=== RowNumber_PerUsp

[cols="d,m,m,m,m,d"]
|===
|
|RowNumber_PerUsp
|bigint
|NULL
|
|
|===


[[column-Sort]]
=== Sort

[cols="d,m,m,m,m,d"]
|===
|
|Sort
|int
|NULL
|
|
|===


[[column-usp_id]]
=== usp_id

[cols="d,m,m,m,m,d"]
|===
|
|usp_id
|int
|NULL
|
|
|===


// end::AntoraColumnDetails[]

== AntoraPkColumnTableRows

// tag::AntoraPkColumnTableRows[]













// end::AntoraPkColumnTableRows[]

== AntoraNonPkColumnTableRows

// tag::AntoraNonPkColumnTableRows[]
|
|<<column-Asc_PerParentChild>>
|bigint
|NULL
|
|

|
|<<column-child_PerParent>>
|bigint
|NULL
|
|

|
|<<column-Depth>>
|int
|NULL
|
|

|
|<<column-Desc_PerParentChild>>
|bigint
|NULL
|
|

|
|<<column-is_condition>>
|tinyint
|NULL
|
|

|
|<<column-is_required_ELSE>>
|int
|NOT NULL
|
|

|
|<<column-Number>>
|int
|NULL
|
|

|
|<<column-Parent_Number>>
|int
|NULL
|
|

|
|<<column-Parent_Sort>>
|int
|NULL
|
|

|
|<<column-Root_Sort>>
|int
|NULL
|
|

|
|<<column-RowNumber_PerUsp>>
|bigint
|NULL
|
|

|
|<<column-Sort>>
|int
|NULL
|
|

|
|<<column-usp_id>>
|int
|NULL
|
|

// end::AntoraNonPkColumnTableRows[]

== AntoraIndexList

// tag::AntoraIndexList[]

// end::AntoraIndexList[]

== AntoraParameterList

// tag::AntoraParameterList[]
* @usp_id (int)
* @Parent_Number (int)
// end::AntoraParameterList[]

== AdocUspSteps

// tag::AdocUspSteps[]

// end::AdocUspSteps[]


== is_repo_managed

// tag::is_repo_managed[]

// end::is_repo_managed[]


== microsoft_database_tools_support

// tag::microsoft_database_tools_support[]

// end::microsoft_database_tools_support[]


== MS_Description

// tag::MS_Description[]

// end::MS_Description[]


== persistence_source_RepoObject_fullname

// tag::persistence_source_RepoObject_fullname[]

// end::persistence_source_RepoObject_fullname[]


== persistence_source_RepoObject_fullname2

// tag::persistence_source_RepoObject_fullname2[]

// end::persistence_source_RepoObject_fullname2[]


== persistence_source_RepoObject_guid

// tag::persistence_source_RepoObject_guid[]

// end::persistence_source_RepoObject_guid[]


== is_persistence_check_for_empty_source

// tag::is_persistence_check_for_empty_source[]

// end::is_persistence_check_for_empty_source[]


== is_persistence_delete_changed

// tag::is_persistence_delete_changed[]

// end::is_persistence_delete_changed[]


== is_persistence_delete_missing

// tag::is_persistence_delete_missing[]

// end::is_persistence_delete_missing[]


== is_persistence_insert

// tag::is_persistence_insert[]

// end::is_persistence_insert[]


== is_persistence_truncate

// tag::is_persistence_truncate[]

// end::is_persistence_truncate[]


== is_persistence_update_changed

// tag::is_persistence_update_changed[]

// end::is_persistence_update_changed[]


== example4

// tag::example4[]

// end::example4[]


== example5

// tag::example5[]

// end::example5[]


== has_history

// tag::has_history[]

// end::has_history[]


== has_history_columns

// tag::has_history_columns[]

// end::has_history_columns[]


== is_persistence

// tag::is_persistence[]

// end::is_persistence[]


== is_persistence_check_duplicate_per_pk

// tag::is_persistence_check_duplicate_per_pk[]

// end::is_persistence_check_duplicate_per_pk[]


== example1

// tag::example1[]

// end::example1[]


== example2

// tag::example2[]

// end::example2[]


== example3

// tag::example3[]

// end::example3[]


== usp_persistence_RepoObject_guid

// tag::usp_persistence_RepoObject_guid[]

// end::usp_persistence_RepoObject_guid[]


== UspExamples

// tag::UspExamples[]

// end::UspExamples[]


== UspParameters

// tag::UspParameters[]

// end::UspParameters[]


== persistence_source_RepoObject_xref

// tag::persistence_source_RepoObject_xref[]

// end::persistence_source_RepoObject_xref[]


== pk_index_guid

// tag::pk_index_guid[]

// end::pk_index_guid[]


== pk_IndexPatternColumnDatatype

// tag::pk_IndexPatternColumnDatatype[]

// end::pk_IndexPatternColumnDatatype[]


== pk_IndexPatternColumnName

// tag::pk_IndexPatternColumnName[]

// end::pk_IndexPatternColumnName[]


== pk_IndexSemanticGroup

// tag::pk_IndexSemanticGroup[]

// end::pk_IndexSemanticGroup[]


== AntoraReferencedList

// tag::AntoraReferencedList[]
* xref:repo.GeneratorUspStep.adoc[]
// end::AntoraReferencedList[]


== AntoraReferencingList

// tag::AntoraReferencingList[]
* xref:repo.GeneratorUspStep_Sql.adoc[]
// end::AntoraReferencingList[]


== ReferencedObjectList

// tag::ReferencedObjectList[]
* [repo].[GeneratorUspStep]
// end::ReferencedObjectList[]


== sql_modules_definition

// tag::sql_modules_definition[]
[source,sql]
----

/*
[repo].[GeneratorUspStep] has a parent child structure
here we try to get the numbers in the right order

it is not perfect if the tree is to deep and some "deep" numbers are lower
check the result per [usp_id]
and if it not fits try to use better sorted numbers


----usage
----and how to get required_Begin_count and required_Begin_count for conditions
--
--get all steps per Usp, recursively:
SELECT u.*
 , t.*
FROM [repo].[GeneratorUsp] u
CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([id], NULL) t
ORDER BY [u].id
 , t.[RowNumber_PerUsp]

----and now about conditions
----all this is done because we need to encapsulate condition THEN and ELSE statement in BEGIN...END blocks
----but need to explore the first and last step per condition THEN- or ELSE-block
--
--get all (is_condition = 1) statements and their recursive children
SELECT [s].[usp_id]
 , [s].[Number] AS [Condition_Number]
 --, [s].[Parent_Number]
 --, [s].[Name]
 --, [s].[has_logging]
 --, [s].[is_condition]
 --, [s].[is_inactive]
 --, [s].[is_SubProcedure]
 --, [s].[Statement]
 --, [s].[log_source_object]
 --, [s].[log_target_object]
 --, [s].[log_flag_InsertUpdateDelete]
 --, [s].[info_01]
 --, [s].[info_02]
 --, [s].[info_03]
 --, [s].[info_04]
 --, [s].[info_05]
 --, [s].[info_06]
 --, [s].[info_07]
 --, [s].[info_08]
 --, [s].[info_09]
 --, [t].[usp_id]
 , [t].[child_PerParent]
 , [t].[RowNumber_PerUsp] AS [RowNumber_PerUspAndCondition]
 , [t].[Number]
 , [t].[Asc_PerParentChild]
 , [t].[Desc_PerParentChild]
 , [t].[is_required_ELSE]
--, [t].[Depth]
--, [t].[is_condition]
--, [t].[Root_Sort]
--, [t].[Parent_Number]
--, [t].[Parent_Sort]
--, [t].[Sort]
FROM [repo].[GeneratorUspStep] AS s
CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([usp_id], [Number]) AS t
WHERE [s].[is_condition] = 1
ORDER BY [s].[usp_id]
 , [Condition_Number]
 , [t].[child_PerParent]
 , [RowNumber_PerUspAndCondition]


--evaluate the count and place of BEGIN and END for condition statements:
--t: all recursive children of any step which is a condition
--this should also work for recursive conditions, because ([s].[is_condition] = 1) will filter any conditions
--([t].[Asc_PerParentChild] = 1) indicates a required BEGIN, these are first children of conditions
--([t].[Desc_PerParentChild] = 1) indicates a required BEGIN, these are last children of condition steps

SELECT [s].[usp_id]
 , [t].[Number]
 , required_Begin_count = SUM(IIF([t].[Asc_PerParentChild] = 1, 1, 0))
 , required_End_count = sum(iif([t].[Desc_PerParentChild] = 1, 1, 0))
 , [is_required_ELSE] = MAX([t].[is_required_ELSE])
FROM [repo].[GeneratorUspStep] AS s
CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([usp_id], [Number]) AS t
WHERE [s].[is_condition] = 1
GROUP BY [s].[usp_id]
 , [t].[Number]


 --combine all active steps per usp with required_Begin_count and required_End_count:

SELECT [u].[id]
 --, [u].[usp_schema]
 --, [u].[usp_name]
 , [u].[has_logging]
 --, [u].[usp_Comment]
 , [u].[usp_fullname]
 --, [t].[usp_id]
 , [t].[Number]
 , [t].[RowNumber_PerUsp]
 , [t].[Depth]
 , [t].[is_condition]
 , [t].[Root_Sort]
 --, [t].[Parent_Number]
 --, [t].[Parent_Sort]
 --, [t].[Sort]
 --, [t].[child_PerParent]
 --, [t].[Asc_PerParentChild]
 --, [t].[Desc_PerParentChild]
 , [BeginEnd].[required_Begin_count]
 , [BeginEnd].[required_End_count]
 , [BeginEnd].[is_required_ELSE]
FROM [repo].[GeneratorUsp] AS u
CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([id], NULL) AS t
LEFT JOIN (
 SELECT [s].[usp_id]
  , [t].[Number]
  , [required_Begin_count] = SUM(IIF([t].[Asc_PerParentChild] = 1, 1, 0))
  , [required_End_count] = SUM(IIF([t].[Desc_PerParentChild] = 1, 1, 0))
  , [is_required_ELSE] = MAX([t].[is_required_ELSE])
 FROM [repo].[GeneratorUspStep] AS s
 CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([usp_id], [Number]) AS t
 WHERE [s].[is_condition] = 1
 GROUP BY [s].[usp_id]
  , [t].[Number]
 ) AS BeginEnd
 ON BeginEnd.usp_id = u.id
  AND BeginEnd.Number = t.Number
ORDER BY [u].[id]
 , [t].[RowNumber_PerUsp]

--and finaly use [repo].[ftv_GeneratorUspStep_sql] to create the statement per step

SELECT [u].[id]
 , [t].[Number]
 , [u].[has_logging]
 , [BeginEnd].[required_Begin_count]
 , [BeginEnd].[required_End_count]
 , [BeginEnd].[is_required_ELSE]
 --only information
 , [u].[usp_fullname]
 , [t].[RowNumber_PerUsp]
 --, [t].[Depth]
 --, [t].[is_condition]
 --, [t].[Root_Sort]
 --, [t].[Parent_Number]
 --, [t].[Parent_Sort]
 --, [t].[Sort]
 --, [t].[child_PerParent]
 --, [t].[Asc_PerParentChild]
 --, [t].[Desc_PerParentChild]
 , sql.SqlStep
FROM [repo].[GeneratorUsp] AS u
CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([id], NULL) AS t
LEFT JOIN (
 SELECT [s].[usp_id]
  , [t].[Number]
  , [required_Begin_count] = SUM(IIF([t].[Asc_PerParentChild] = 1, 1, 0))
  , [required_End_count] = SUM(IIF([t].[Desc_PerParentChild] = 1, 1, 0))
  , [is_required_ELSE] = MAX([t].[is_required_ELSE])
 FROM [repo].[GeneratorUspStep] AS s
 CROSS APPLY [repo].[ftv_GeneratorUspStep_tree]([usp_id], [Number]) AS t
 WHERE [s].[is_condition] = 1
 GROUP BY [s].[usp_id]
  , [t].[Number]
 ) AS BeginEnd
 ON BeginEnd.usp_id = u.id
  AND BeginEnd.Number = t.Number
CROSS APPLY [repo].[ftv_GeneratorUspStep_sql]([u].[id], [t].[Number], [u].[has_logging], [BeginEnd].[required_Begin_count], [BeginEnd].[required_End_count], [BeginEnd].[is_required_ELSE]) sql
ORDER BY [u].[id]
 , [t].[RowNumber_PerUsp]


*/
CREATE FUNCTION [repo].[ftv_GeneratorUspStep_tree] (
 @usp_id INT
 , @Parent_Number INT
 --, @usp_has_logging TINYINT = 0
 )
RETURNS TABLE
AS
RETURN (
  WITH tree AS
   --tree is recursive to solve parent child hierarchies
   (
    SELECT [usp_id]
     , [Number]
     , [Parent_Number]
     , 0 AS [Depth]
     , [Number] AS [Sort]
     , [Number] AS [Parent_Sort]
     , [Number] AS [Root_Sort]
     , [is_condition]
     , [child_PerParent] = IIF(NOT [Parent_Number] IS NULL, ROW_NUMBER() OVER (
       PARTITION BY [usp_id]
       , [Parent_Number] ORDER BY [Number]
       ), NULL)
    --ROW_NUMBER() OVER(Partition by [usp_id], [Parent_Number] ORDER BY [Number])
    FROM [repo].[GeneratorUspStep]
    WHERE
     --
     [usp_id] = @usp_id
     AND [is_inactive] = 0
     AND (
      [Parent_Number] = @Parent_Number
      OR @Parent_Number IS NULL
      AND [Parent_Number] IS NULL
      )
    
    UNION ALL
    
    SELECT [child].[usp_id]
     , [child].[Number]
     , [child].[Parent_Number]
     , [parent].[Depth] + 1
     , [child].[Parent_Number] AS [sort]
     , [parent].[Sort] AS [Parent_sort]
     , [parent].[Root_Sort] AS [Root_Sort]
     , [child].[is_condition]
     , [child_PerParent] = [parent].[child_PerParent]
    FROM [repo].[GeneratorUspStep] AS child
    INNER JOIN tree AS parent
     ON child.[Parent_Number] = parent.Number
    WHERE
     --
     [child].[usp_id] = @usp_id
     AND [child].[is_inactive] = 0
    )
   , tree_2 AS
   --tree_2 is required to calculate the correct step order: [RowNumber_PerUsp]
   (
    SELECT
     --
     [tree].[usp_id]
     , [tree].[Number]
     , [RowNumber_PerUsp] = ROW_NUMBER() OVER (
      PARTITION BY [tree].[usp_id] ORDER BY [tree].[Root_Sort]
       , [tree].[Parent_Number]
       , [tree].[Parent_Sort]
       , [tree].[Sort]
      )
     , [tree].[Depth]
     , [tree].[is_condition]
     , [tree].[Root_Sort]
     , [tree].[Parent_Number]
     , [tree].[Parent_Sort]
     , [tree].[Sort]
     , [tree].[child_PerParent]
    FROM tree
    )
   , tree_3 AS
   --final query is used to calculate Asc_PerParentChild and Desc_PerParentChild
   --Asc_PerParentChild is the first step per [child_PerParent]
   --if the @Parent_Number has [is_condition] = 1
   --then [child_PerParent] = 1 is the THEN block an [child_PerParent] = 2 is the ELSE block
   --to encapsulate THEN and ELSE block:
   --a 'BEGIN' is required before Asc_PerParentChild = 1
   --a 'END' is required after Desc_PerParentChild = 1
   (
    SELECT
     --
     *
     , [Asc_PerParentChild] = ROW_NUMBER() OVER (
      PARTITION BY [usp_id]
      , [child_PerParent] ORDER BY [RowNumber_PerUsp]
      )
     , [Desc_PerParentChild] = ROW_NUMBER() OVER (
      PARTITION BY [usp_id]
      , [child_PerParent] ORDER BY [RowNumber_PerUsp] DESC
      )
    FROM tree_2
    )
  SELECT
   --
   *
   --[child_PerParent] = 2 is the ELSE-block, if the parent is a condition
   --in front of the ELSE block the 'ELSE' is required
   , is_required_ELSE = IIF([child_PerParent] = 2
    AND [Asc_PerParentChild] = 1, 1, 0)
  FROM tree_3
  )

----
// end::sql_modules_definition[]


