= Database documentation generator

[abstract]
== Abstract

* setup Antora (one time task)
* setup sqldb-docs repository (one time per database task)
* setup Antora Playbook project (one time per project task)
* setup _optional_ additional docs repositories containing additional documentation (one time per project task)
* recurring steps
** Export files for Antora
+
.AntoraExport
====
[source,sql]
----
include::sqldb:partial$docs.usp_AntoraExport.adoc[tag=exampleusage]
----
====
+
** generate the static site
+
In the Antora Playbook project call Antora to build the local or the final site.
+
*** You can use the prepared PowerShell scripts
+
[source,powershell]
....
./local-playbook.ps1
....
+
[source,powershell]
....
./playbook.ps1
....
*** you can also use Windows bat files:
+
[source]
....
local-playbook.bat
....
+
[source]
....
playbook.bat
....

== Why Datahandwerk Documentation Generator?

=== Unique selling propositions and requirements

* It's *free and open source*
** It can be used anywhere where it is allowed and possible to install Antora
* *Combination of business and technical documentation*
** It should be possible to combine business and technical content in one (or more) holistic documentation(s).
** There should be *links* between the documentation of technical database objects and domain-oriented articles.
* *Common data source* for optionally different documentation.
** It's possible to create different documentations for different purposes: a user potentially has different interests than a auditor or a database developer.
** There should be common data sources for the documentations so that changes in the documentation sources have the same effect wherever they are used. A measure, KPI, column, or concept should be documented in one place.
* Documentation under *version control*
** The secondary data sources of the documentation(s) created from different primary sources and combined should also be under version control. From this, different documentation can be created in different versions and from different components.
* Easy *switching between different versions of the documentation*
** While some users are only interested in the documentation of the current version, for other users it may be important to have several versions documented together and to be able to switch between the versions.
* Use of *plain text formats (markup languages)*
** For optimal version control of the content, it makes sense to use plain-text formats for the sources of the documentation, such as Markdown or Asciidoc.
* portable documentation
** If documentation is created as a *static website* with relative links, then it will work in any location on a filesystem as well as on a web server.
* *Docs as Code*
+
--
What does "Docs as Code" mean?

Create and manage documentation like code:

* under *version control*
* with tests
* and a build system for build and deployment.

One key is to use a _plain text format_ for documentation. Here are some links to websites that describe the concept in a bit more detail.

* https://www.writethedocs.org/guide/docs-as-code/[Docs as Code]
* https://docs-as-co.de/[Documentation As Code]
* https://www.informatik-aktuell.de/entwicklung/methoden/docs-as-code-die-grundlagen.html[Docs-as-Code -- Die Grundlagen]
--

=== special requirements for technical database documentation

* Use of *extended properties*
* *Virtual indexes, PK and FK*
+
--
In SQL Server, only real indexes, PK and FK can be stored, and only to tables.

On the other hand there are important virtual relations between objects, which should be defined and documented

** virtual PK of views (or also tables)
** virtual foreign key relationships
** virtual indexes, for example the combination of different columns with the same functional meaning. These indexes of the same meaning can be assigned to the same "index semantics group" to map a domain-oriented relationship.
--
* *virtual references*
+
--
Information about referenced and referencing objects can be taken from the metadata of databases.

With columns this looks rather bad and is only possible under certain conditions.

In an associated repository you can store virtual references:

* References between tables whose data flow results from procedures. +
The SQL Server only shows that the procedure depends on tables. However, it does not know from where to where data flows.
* virtual references between columns of different objects can be
** by analyzing the code of views with a sqlparser
** add them manually or by code
--
* *Data-Lineage*
+
--
The documentation should contain https://de.wikipedia.org/wiki/Data-Lineage[Data-Lineage] on object level and on column level. For this purpose, the information that can be taken directly from the SQL Server (referenced and referencing objects) is to be used.

Especially important and valuable is the use of additional virtual column references.
--
* *Inheritance of properties along a data lineage*
+
--
It should be possible to define functional descriptions of tables and columns at exactly one point and to inherit these descriptions along the column data lineage. One must be able to force this inheritance on the one hand, one must be able to cancel it also consciously, if at a certain place the description is to be changed.

It is possible to store descriptions for objects or columns already in the "Source" (or to import them from their source), which are inherited up to the "Datamart". They are also taken over from there into the subsequent SSAS model.
--
* Take over code of calculated columns into description
+
--
For calculated columns it should be possible to take over the code of the calculation as description. If possible, the code could contain descriptions in comments.

Unfortunately, this is not possible in calculated columns of tables, because SQL Server reformats calculated columns when saving them.
--
* Extracting documentation from comments of views and procedures
+
--
All SQL servers, which can be created by code, allow the use of comments. It should be possible to extract specially marked areas from comments and use them in the documentation. This can be descriptions, application examples, etc.

Here an example, how in the code of a procedure in the comment different additional information is deposited and extracted as description and examples:

xref:dhw:sqldb:repo.usp_persistence_set.adoc[]
--

=== Alternatives for technical documentation of databases

https://dbmstools.com/categories/database-documentation-tools/sqlserver[database-documentation-tools/sqlserver]

If it is "only" about a technical documentation of databases, then you can find very good and usable tools here. However, these tools *are not suitable for a combined business and technical documentation*. Nevertheless, I have practiced this for many years, trying to place all technical descriptions somehow in the database (for example in extended properties), so that there is _one_ source for the documentation. You can get quite far with this, especially

* if you find a mechanism to inherit descriptions along dependencies
* if one can enrich the databases with further metadata:
** virtual PK
** virtual PK-FK relations
** virtual relations (dependencies)

Most of these products *do not support the use of markup languages* like Markdown or Asciidoc in descriptions, except for these, supporting Markdown:

* SchemaSpy
* SentryOne Database Mapper

The best tool seems to be:

* SentryOne Database Mapper
* by far: Datadeo
* then the rest with often comparable features (no diagrams, output only as tables, dependencies only on object level)

=== Markup language Asciidoc

My clear recommendation of an markup language is *Asciidoc*. Why, I have briefly described in a blog article (in German):

http://datahandwerk.aisberg.de/2021-04-20-docs-code-mit-asciidoc-und-antora/

*Markdown* is the most widely used, but there is not one Markdown, but several "dialects". A major disadvantage of Markdown is that you cannot include content from other files as "include". A Markdown file is always a single entity and can only reference (include) images (and maybe videos).

*reStructuredText* offers no advantages over Markdown or Asciidoc, in my opinion.

*Asciidoc* convinced me as the clear winner in the comparison:

* Especially valuable is the possibility to include content from other documents as `includes`.
* Variables can be used.
* There is _one_ syntax, and not dozens of dialects.
* The syntax is as simple as Markdown.
* The possibilities of the formatting are substantially more extensive, than those of Markdown.
* With https://github.com/asciidoctor/kramdown-asciidoc[Kramdown AsciiDoc (Markdown to AsciiDoc)] you can convert Markdown to Asciidoc.

Links to Asciidoc

* https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/

=== Antora - Docs-As-Code with Asciidoc

Since I decided to use the more powerful markup language Asciidoc and against Markdown, as justified above, the best framework for _docs-as-code with Asciidoc_ in my opinion is https://antora.org/[Antora]. This tool is created and maintained by the same developers who develop AsciiDoctor. I have come to the conclusion that if you want to run Docs-as-Code with Asciidoc, it will be hard to find anything better.

== How does it work?

In the repository database, the xref:dhw:sqldb:configT.type.adoc[] view hard-codes which object types are exported to the documentation. In xref:dhw:sqldb:repo.RepoObject.adoc[] it can be defined in the column `is_DocsExclude` that individual RepoObject should be additionally excluded from the documentation.

The basic idea is based on the use of `include` in asciidoc documents.

* For each object to be documented, different files are exported to different folders, which always have the same file name. The pattern for this is `SchemaName.ObjectName.adoc`
** folder `pages`
+
--
Each file has the same content, an include of one or more template files.

The exact content is specified in xref:dhw:sqldb:config.Parameter.adoc[] and can be customized for specific projects.

====
 include::partial$template/master-page-1.adoc[]
 include::partial$template/master-page-examples.adoc[]
 include::partial$template/master-page-4.adoc[]
 include::partial$template/master-page-5_references.adoc[]
 include::partial$template/master-page-6.adoc[]
====
--
** folder `partials\template`
+
--
contains the templates that define the concrete contents. +
(The real content has no spaces at the beginning of each line. These are necessary here to prevent an `include`).

====
----
    = {docname} <1>

    include::partial${docname}.adoc[tag=existing_properties] <3>
    include::partial${docname}.adoc[tag=boolean_attributes]

    type:
    include::partial${docname}.adoc[tag=SysObject_type]
    (
    include::partial${docname}.adoc[tag=SysObject_type_name]
    ), modify_date:
    include::partial${docname}.adoc[tag=SysObject_modify_date]

    RepoObject_guid:
    include::partial${docname}.adoc[tag=RepoObject_guid]

    ifdef::is_repo_managed[] <2>
    is_repo_managed: 1
    endif::is_repo_managed[] <2>

    ifdef::is_ssas[] <2>
    is_ssas: 1
    endif::is_ssas[] <2>

    ifdef::ExistsProperty--MS_Description[] <2>

    == Description

    include::partial${docname}.adoc[tag=ms_description]

    endif::ExistsProperty--ms_description[] <2>
----
<1> By using `\{docname}` the name of the file corresponding to the object ("SchemaName.ObjectName") is applied in the template.
<2> using `ifdef`, `ifndef`, `endif` it is possible to include content only if certain conditions are met.
<3> include object specific content from the objects main partial file, using tags +
See: https://docs.asciidoctor.org/asciidoc/latest/directives/include-tagged-regions/[Include Content by Tagged Regions]
====
--
** folder `partials\puml`
+
--
contains different sub folders with different PlantUML diagrams per object
--
** folder `partials\navlist`
+
--
contains different Antora navigation lists
--
** folder `partials\docsnippet`
+
--
contains optional additional partial documents which could be used in project specific documentation
--
** folder `partials` (no subfolder)
+
--
contains one partial document for each object, containing all object specific content, which should or could be used in the documentation for this object.

See: https://docs.asciidoctor.org/asciidoc/latest/directives/include-tagged-regions/[Include Content by Tagged Regions]

The content is addressed and used via the template files.
--

== Setup for Antora usage

https://docs.antora.org/antora/2.3/install-and-run-quickstart/[Install and Run Antora Quickstart]

https://docs.antora.org/antora/2.3/how-antora-works/[How Antora Works]

____
Antora’s default site generator handles all aspects of creating a documentation site, from fetching and aggregating to converting and arranging the content to publishing the files of the generated site.
____

We recommend using at least two git repositories, one for the documentation content, another for the playbooks and the final generated documentation.

It is a good idea to use additional docs repositories for additional manually created documentation.

=== setup sqldb-docs repositories

Antora can collect the content from different repositories. So, if you want to combine the database documentation with other content, you can also distribute this content to different repositories. For example, the DataHandwerk documentation combines architecture, manual, and database documentation in a common and interlinked documentation. And we use two source repositories:

* https://github.com/DataHandwerk/DataHandwerk-docs contains manually created content like architecture, manual
* https://github.com/DataHandwerk/sqldb-docs contains automatically created content, created using xref:sqldb:docs.usp_AntoraExport.adoc[]

steps

* create a new git repositories per database, in our case this is https://github.com/DataHandwerk/sqldb-docs
** you can create and use local repositories
** if you want to combine the documentation for several databases in one documentation project, and you want to link between them, then you should use different Settings in the Parameter "AntoraModulName" for each database (for example "sqldbedw", "sqldbdm") and related different repositories like "MyProject-sqldbedw-docs" and "MyProject-sqldbdm-docs"
* *at least one commit is required to enable Antora to use any repository*
* create required folder structure +
On Windows you can use `xcopy` to copy an existing folder structure without files
+
[source]
----
xcopy C:\SourceFolder D:\TargetFolder /t /e
----
+
[source]
----
xcopy D:\Repos\GitHub\DataHandwerk\sqldb-docs D:\Repos\aaa\bbb\MyDataBase_sqldb /t /e
----
+
////
in the following steps replace "D:\Repos\GitHub\DataHandwerk\sqldb-docs" by your own folder and repository name
+
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\attachments (optional)
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\examples (optional)
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\images (optional)
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\pages
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\pages\index
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\pages\nav
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\pages\other (optional)
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\docsnippet
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\navlist
*** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml
**** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml\entity_0_30_objectref
**** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml\entity_1_1_colref
**** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml\entity_1_1_fk
**** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml\entity_1_1_objectref
**** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\partials\puml\entity_30_0_objectref
////
* if you don't use the default AntoraFolderName "sqldb" then rename the folder to your AntoraFolderName
* create the Antora navigation file +
You can copy an existing file (and adapt if required)
** D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\nav.adoc
** file content (Remove the `/` at the beginning of the line before the `include`.)
+
....
/include::partial$navlist/nav-by-schema.adoc[]
* xref:other/IndexSemanticGroup.adoc[]
....
* update the parameter 'Adoc_AntoraDocModulFolder'
====
[source,sql]
----
--avoid "\" at the end of the Parameter_value!
Update
    [config].[Parameter]
Set
    [Parameter_value] = 'D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules'
Where
    [Parameter_name]  = 'AntoraModulFolder'
    And sub_Parameter = '';
----
====
* your source repositories should contain a file `antora.yml` in the same folder, where the folder `modules` is located. Read about `antora.yml` in https://docs.antora.org/antora/2.3/component-version-descriptor/
+
In DataHandwerk We use two (2) docs source repositories, and we need the `antora.yml` in each source repository. The `title` should be contained only in the main `antora.yml`.
+
The DataHandwerk content of `"D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\antora.yml"` is
+
====
[source,yaml]
....
name: myproject <1>
# title: My Project <2>
version: 0.1.0 <3>
# nav:
# - modules/sqldb/nav.adoc <4>
....
<1> use the same project name in all `antora.yml`
<2> don't define a title here, but define it only once in the main `antora.yml`
<3> use the same version(s) to get a consistent documentation
<4> don't include the `sqldb` navigation file here, but use the main `antora.yml` to define the whole navigation in one place!
====

=== setup additional docs source repository

DataHandwerk `sqldb-docs` contains only automatically generated documentation. Additional manual documentation is located in an additional repository `DataHandwerk-docs`

you can use xcopy to get a folder structure to start your own documentation: +
[source]
----
xcopy D:\Repos\GitHub\DataHandwerk\DataHandwerk-docs D:\Repos\aaa\bbb\MyDataBase-docs /t /e
----

DataHandwerk main `antora.yml` is located in `D:\Repos\GitHub\DataHandwerk\DataHandwerk-docs\docs` and has this content

====
[source,yaml]
....
name: myproject <1>
title: My Project
version: 0.1.0
nav: <2>
- modules/ROOT/nav.adoc
- modules/arc/nav.adoc
- modules/sqldb/nav.adoc <3>
- modules/manual/nav.adoc
....
<1> this project name is used in the playbooks
<2> 4 navigation files for 4 modules are included
<3> include the navigation file for `sqldb` module in the main `antora.yml`
====

You could copy this file and modify.

==== add index.adoc to be used as starting point

It is useful to create a file `index.adoc` and define this file as the entry point of a documentation project. Place this file in `pages` of the `ROOT` module of the docs repository. Of course, you can also define a different entry point.

=== setup Antora Playbook project

learn about https://docs.antora.org/antora/2.3/playbook/[the Antora Playbook]

____
An Antora playbook makes it easy for technical writers to control what content is included in your site, what user interface (UI) is applied to it, and where the site is published using a playbook file. The settings in the playbook file, in combination with CLI options and environment variables, tell Antora how to operate.
____

____
A playbook is usually located in a playbook project. A playbook project repository is responsible for generating a documentation site. It’s strictly a _configuration as code_ repository—​it does not contain any content. Instead, it contains a playbook file, and, in certain situations, supplemental UI files and extension code.
____

Create a new project folder, for example
`D:\Repos\aaa\bbb\MyProject-site`

Copy some files and folders from the DataHandwerk project and adapt them:

* `supplemental-ui` (Folder)
* local-playbook.bat
* local-playbook.ps1
* local-playbook.yml
* playbook.bat
* playbook.ps1
* playbook.yml
* local-playbook-validate.ps1
* .gitignore


DataHandwerk documentation uses the following Playbook project: https://github.com/DataHandwerk/datahandwerk.github.io +
It is also the output for the generated documentation.

==== Some content explained

* two (2) playbooks are included, one to create local output, one to create the final site.
** They are different in the output folder.
** they are different in the `kroki-fetch-diagram: true` option. It takes a lot of time to generate all diagrams and this option is used only to create the final site.
** They could be also different in sources for testing
+
====
[source,yaml]
....
site:
  title: DataHandwerk Docs
  url: https://DataHandwerk.github.io
  start_page: dhw::index.adoc <1>
  # start_page: dhw:arc:architecture.adoc
  keys:
    google_analytics: 'G-abcdefghij'
content:
  sources:
  - url: D:\Repos\GitHub\DataHandwerk\DataHandwerk-docs
    branches: HEAD
    start_path: docs
  - url: D:\Repos\GitHub\DataHandwerk\sqldb-docs
    branches: HEAD
    start_path: docs
asciidoc:
  attributes:
    page-pagination: ''
    experimental: ''
    :plantuml-server-url: http://www.plantuml.com/plantuml
    # You can use the kroki-fetch-diagram option to download the images from Kroki at build time. In other words, while viewing pages you won't rely on Kroki anymore.
    # However, in Antora, this is not currently compatible with inline SVG images.
    # kroki-fetch-diagram: true <3>
  extensions:
  - asciidoctor-kroki <2>
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/master/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
  supplemental_files: ./supplemental-ui <5>
output:
  clean: true
  dir: ./local <4>
urls:
  redirect_facility: static
runtime:
  fetch: true <6>
....
<1> in case you have only the database documentation you need to set the `start_page` to some page in your module (for example 'myproject:sqldb:dbo.MyTable.adoc'). 'dhw' or 'myproject' is the project name defined in the `antora.yml`
<2> required to render diagrams
<3> kroki-fetch-diagram is required for the final site, but it takes a lot of time and should be disabled if you want to check the results locally. Keep in mind that some big diagrams will not be shown if this option is disabled, but they will be rendered for the final site if enabled
<4> put the output dir for the local playbook into `.gitignore` to exclude from version control
<5> the antora-ui-default needs to be adapted a bit to show your own menu content
<6> force source repository fetch in General instead of using it every time in the antora command
====
* the ".gitignore" file should contain some entries to avoid committing some content into the repository.
+
====
....
/local <1>
node_modules
npm
.idea
package-lock.json
build
....
====
<1> exclude the site generated from the local-target playbook from source control
* D:\Repos\GitHub\DataHandwerk\datahandwerk.github.io\supplemental-ui
+
--
Before creating a completely custom Antora UI, you can use the default UI within certain limits and overwrite some components.

To do this, you can look at the https://gitlab.com/antora/antora-ui-default[repository of the Antora Default UI] and try to understand its elements to overwrite individual files. The structure used is located in the `src` folder.

* `\partials\header-content.hbs` +
this file should be customized to adapt menu structure in the header
* `\partials\head-styles.hbs` +
one line is added to use `\css\custom.css` to overwrite some css styles
* `\css\custom.css` +
some changes to enlarge the wight of navigation bar, TOC section and maximum content with. +
The font size of the navigation bar was decreased to avoid too much line breaks for long object names.
--
+
* some scripts to simplify the call of Antora (optional)
** local-playbook.ps1
+
[source,powershell]
....
antora --fetch local-playbook.yml
....
** local-playbook-validate.ps1
+
[source,powershell]
....
antora --generator @antora/xref-validator local-playbook.yml
....
+
https://gitlab.com/antora/xref-validator/
+
`$ npm install -g gitlab:antora/xref-validator`
** playbook.ps1
+
[source,powershell]
....
antora --fetch playbook.yml
New-Item .\docs\.nojekyll -ItemType file -Force <1>
....
<1> the file `.nojekyll` needs to be created if the site should be published as GitHub page. See: https://docs.antora.org/antora/2.3/publish-to-github-pages/#nojekyll
** playbook.bat
+
[source]
....
antora --fetch playbook.yml
copy /y NUL .\docs\.nojekyll <1>
....
<1> the file `.nojekyll` needs to be created if the site should be published as GitHub page. See: https://docs.antora.org/antora/2.3/publish-to-github-pages/#nojekyll

== Export files for Antora

include::sqldb:partial$docs.usp_AntoraExport.adoc[tag=ms_description]

.Usage
====
[source,sql]
----
include::sqldb:partial$docs.usp_AntoraExport.adoc[tag=exampleusage]
----
====

== generate the static site

NOTE: The parameter 'dwh_readonly' is 0 by default. +
No guid will be written as extended properties into the connected DWH database. This parameter should and can remain 0 if a database should only be documented but not modified.

IMPORTANT: Antora uses git repositories as sources. You must put the source repositories under Git version control, there must be at least one commit.

IMPORTANT: Antora Export will not delete any content. After Antora Export and before creating the site you should check the `D:\Repos\GitHub\DataHandwerk\sqldb-docs\docs\modules\sqldb\pages` for outdated files and delete them to avoid them to be generated. Just sort the folder by file creation date. +
You can also clean up the partials. This is not so important, because these files are only used when they are included into the pages.

export the automated documentation
[source,sql]
----
--initial setup
Exec repo.usp_main;

--use the sqlparser
--...
--after using the sqlparser persist the results

Exec sqlparse.usp_PERSIST_RepoObject_SqlModules_41_from_T;
Exec sqlparse.usp_PERSIST_RepoObject_SqlModules_61_SelectIdentifier_Union_T;

--process the sqlparser results
Exec repo.usp_main;

--import extended properties from source database into repository
Exec [property].[usp_sync_ExtendedProperties_Sys2Repo_InsertUpdate]

--export files for automated documentation
Exec docs.usp_AntoraExport

----



In the Antora Playbook project call Antora to build the local or the final site.

* You can use the prepared PowerShell scripts
+
[source,powershell]
....
./local-playbook.ps1
....
+
[source,powershell]
....
./playbook.ps1
....
* you can also use Windows bat files:
+
[source]
....
local-playbook.bat
....
+
[source]
....
playbook.bat
....


The result is a static site. You can browse the content locally on the PC where you created the documentation.

If you want to publish the site as GitHub page, you need to create `.nojekyll`: https://docs.antora.org/antora/2.3/publish-to-github-pages/#nojekyll

=== use local PlantUML Server

It is possible to use a local PlantUML server.

https://plantuml.com/server

https://sourceforge.net/projects/plantuml/ +
here you can download a plantuml.war file to be used in a local webserver lice tomcat.

// tag::to-do[]
// end::to-do[]
